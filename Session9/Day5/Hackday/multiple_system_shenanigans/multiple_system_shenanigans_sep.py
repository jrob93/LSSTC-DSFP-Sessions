'''
investigate multiplicity of systems. Uses dfs generated by plot_binary_evolution.py
'''
from matplotlib import rc
rc('font',**{'size':9})

import pandas as pd
import numpy
import py_func as pf
import matplotlib.pyplot as pyplot
import matplotlib.gridspec as gridspec
import matplotlib.colors
import os
import glob

from sklearn.neighbors import KernelDensity

def kde_sklearn(data, grid, bandwidth = 1.0, **kwargs):
    kde_skl = KernelDensity(bandwidth = bandwidth, **kwargs)
    kde_skl.fit(data[:, numpy.newaxis])
    log_pdf = kde_skl.score_samples(grid[:, numpy.newaxis]) # sklearn returns log(density)

    return numpy.exp(log_pdf)

compile=0

if compile==1:

    # Load the dfs
    path="/Users/jrobinson/xq1_grav_cloud/binary_stability/orbit_results/orbit_results_plots"
    dat_path="/Users/jrobinson/cloud_runs_data/data/jakita_raid2/jer/grav_cloud"
    restart_path="/Users/jrobinson/xq1_grav_cloud/binary_stability/cloud_runs_helio/restart_dirs_N100_f1"

    df_plot_all=pd.read_csv("{}/df_plot_100_all.txt".format(path),sep="\t",index_col=0)
    df_plot_all_stable=pd.read_csv("{}/df_plot_100_all_stable.txt".format(path),sep="\t",index_col=0)

    # df_plot_all=df_plot_all[df_plot_all["N_sys"]>1]
    df_plot_all_stable=df_plot_all_stable[df_plot_all_stable["N_sys"]>1]

    # print df_plot_all
    print df_plot_all_stable
    print numpy.unique(df_plot_all_stable['run']),len(numpy.unique(df_plot_all_stable['run']))
    # print list(df_plot_all_stable)
    # exit()

    rel_sep=[]
    mass_ratio=[]
    inner_orb=[]

    # multiple systems
    N_mult=[3,4]
    for N in N_mult:
        df_mult=df_plot_all_stable[df_plot_all_stable['N_sys']==N]
        print df_mult[['run','R_eq(m)','f','X','i_orig','m1(kg)','m2(kg)','N_sys']]

        # load the collision file
        for i in range(len(df_mult)):
            r_split=df_mult.iloc[i]['run_dir'].split("/")
            run=r_split[-1]
            set=r_split[-2]
            pri=df_mult.iloc[i]['i_orig']
            print set,run,pri

            orb_file="{}/{}_{}_{}/{}_{}_{}_orbit_search_faster_hel.txt".format(restart_path,run,set,int(pri),run,set,int(pri))
            df_orb=pf.load_orb_file(orb_file)
            # print df_orb
            df=df_orb[df_orb['t(s)']==numpy.amax(df_orb['t(s)'])]

            #laod run params
            data_path="{}/{}/{}".format(dat_path,set,run)
            files=next(os.walk(data_path))[2] #retrieve the files in the run directory
            files.sort() #ensure that the files are always sorted the same?
            rp_files = [ fi for fi in files if fi.endswith(".txt") and fi.startswith("run_params") ]
            df_rp=pf.load_run_params("{}/{}".format(data_path,rp_files[-1]))

            # load last restarted data file
            restart_dir="{}/{}_{}_{}".format(restart_path,run,set,int(pri))
            list_of_files = glob.glob("{}/*".format(restart_dir))
            dat_file_list=[f for f in list_of_files if "dat" in f and f.endswith(".txt")]
            dat_file_list.sort()
            latest_dat_file = dat_file_list[-1]

            df=pf.create_df_tot(run,df,df_rp,latest_dat_file) # use original df_rp
            df=pf.binary_selector(df)
            df=df.sort_values(['m1(kg)','m2(kg)'],axis=0,ascending=False) #sort in descending order of mass

            # print df.iloc[0][['run','i','j','m1(kg)','m2(kg)','m2/m1','R_hill(m)']]
            a_bin=df.iloc[0]['a(m)']
            R_hill=df.iloc[0]['R_hill(m)']
            m1=df.iloc[0]['m1(kg)']
            m2=df.iloc[0]['m2(kg)']
            rel_sep.append(a_bin/R_hill)
            mass_ratio.append(m2/m1)

            # print sum(df['a(m)']<a_bin)
            if sum(df['a(m)']<a_bin)==0:
                inner_orb.append(1)
            else:
                inner_orb.append(0)
            # exit()

    rel_sep=numpy.array(rel_sep)
    numpy.save("multiple_system_shenanigans_sep_rel_sep.npy",rel_sep)

    mass_ratio=numpy.array(mass_ratio)
    numpy.save("multiple_system_shenanigans_sep_mass_ratio.npy",mass_ratio)

    inner_orb=numpy.array(inner_orb)
    numpy.save("multiple_system_shenanigans_sep_inner_orb.npy",inner_orb)

rel_sep=numpy.load("multiple_system_shenanigans_sep_rel_sep.npy")
print rel_sep
mass_ratio=numpy.load("multiple_system_shenanigans_sep_mass_ratio.npy")
print mass_ratio
inner_orb=numpy.load("multiple_system_shenanigans_sep_inner_orb.npy")
print inner_orb

fig = pyplot.figure()
gs = gridspec.GridSpec(1,1)
ax1=pyplot.subplot(gs[0,0])

# plot_name="hist"
# # ax1.hist(rel_sep,density=True,bins='auto',edgecolor="k")
# ax1.hist(rel_sep,density=True,bins=20,edgecolor="k")
#
# # add KDE
# bw=0.05
# grid_x=numpy.linspace(0,0.5)
# PDF_x = kde_sklearn(rel_sep, grid_x,bandwidth=bw)
# ax1.plot(grid_x,PDF_x,color="k")
#
# ax1.axvline(numpy.median(rel_sep),color="r")

plot_name="scatter"
for i in range(len(rel_sep)):
    if inner_orb[i]==1:
        c="r"
        l="inner orbit"
    else:
        c="b"
        l="not inner orbit"
    ax1.scatter(rel_sep[i],mass_ratio[i],color=c,label=l)

ax1.set_xlabel("a_bin/R_Hill")
ax1.set_ylabel("m2/m1")

# Remove duplicates from legend
handles, labels = ax1.get_legend_handles_labels()
from collections import OrderedDict
by_label = OrderedDict(zip(labels, handles))

ax1.legend(by_label.values(), by_label.keys())#,prop={'size': 6})

#save the figure
script_name=os.path.basename(__file__).split('.')[0]
picname="{}_{}.png".format(script_name,plot_name)
print "save {}".format(picname)
pyplot.savefig(picname)

picname="{}_{}.pdf".format(script_name,plot_name)
print "save {}".format(picname)
pyplot.savefig(picname)

pyplot.show()
# pyplot.close()

pyplot.show()
